Задание:
1.парсинг командной строки
2.обход файловой системы (обход в глубину с фильтрами)(на выходе у нас есть вектор путей отсортированных по размеру)
(такой вопрос мы же получаем std::vector<boost::filesystem::path> all_files  нам надо как то из всех этих файлов отобрать которые то есть нам надо создать словарь где ключом будет размер а значением список  путей  и вот как создадим словарь проверим его пробежимся по нему  и будем проверять значение длина списка если больше 1 то оставляем иначе удаляем и словаря. потом мы снова из словаря  бежим по словарю и добавляем все в std::vector<списков>

4.Все а дальше уже будет другой класс как раз принимать в конструкторе std::vector<списков> и работать с ним бежать по вектору по индексам брать первый список и первый элемент. списке полностью его хэшировать блоками и дальше идти к следующему в списке элементу и хешировать его блоками и каждый блок проверять с эталоном первым который полностью был захэширован)

группировка по размеру и хэширование блоков(проверка хэшей)

ЧТО ИЗ boost будем юзать:
1.Boost.Program_options (парсинг командной строки) https://www.boost.org/doc/libs/latest/doc/html/program_options/tutorial.html#id-1.3.29.4.3        https://habr.com/ru/articles/174347/
2.Boost.Filesystem(для работы с файловой системой) https://www.boost.org/doc/libs/1_34_0/libs/filesystem/doc/index.htm
3.boost::crc (вот хз тут можно мою реализацию взять с питона :),впадлу на с++ ее переписывать так что будем использовать с boost модуль )
4.boost::algorithm::to_lower (для обработки масок без учета регистра)

Паттерны проектирования:
Итератор(Iterator) - обход файловой системы




ЭТАП 1.Считать с командной строки параметры правильно в переменные(ИСПОЛЬЗОВАТЬ РЕАЛИЗАЦИЮ  ИЗ БИБЛИОТЕКИ boost)

Параметры, которые указаны в задании:
--include или -i - директории для сканирования
--exclude или -e - директории для исключения
--level или -l - уровень сканирования
--min-size или -m - минимальный размер файла
--mask - маски файлов
--block-size или -S - размер блока (S)
--hash или -H алгоритм хеширования (crc32/md5)//буду юзать только crc32


ЭТАП 2.Использовать crc32 для хэширования блоков

1. Вычисление CRC32 для блока данных
Сначала необходимо получить контрольную сумму для конкретного блока данных, который вы хотите кэшировать.
Предположим, у вас есть блок данных (например, файл, строка, или объект в памяти):
Блок данных = "Контент, который нужно закешировать"
Вы применяете к нему алгоритм CRC32 и получаете 32-битное число (которое обычно представляют в виде 8-символьной шестнадцатеричной строки):
CRC32(Блок данных) = "a5e2c4d1" (пример)

2. Использование CRC32 как ключа кэша
Это значение "a5e2c4d1" становится ключом (Key) в вашем механизме кэширования (например, в словаре, базе данных Redis, Memcached или файловой системе).
Вы сохраняете исходный блок данных, ассоциируя его с этим ключом:
Кэш:
{
  "a5e2c4d1": "Контент, который нужно закешировать"
}

3. Процесс проверки кэша (Чтение)
Когда в следующий раз вам понадобятся те же данные:
Вычисляете CRC32 от идентификатора нужного вам блока данных (или от самого блока, если он у вас есть).
Проверяете наличие ключа "a5e2c4d1" в вашем кэше.
Если ключ найден (Cache Hit): вы мгновенно получаете данные из кэша. Это быстро.
Если ключ не найден (Cache Miss): вы генерируете/загружаете данные из первоисточника (база данных, API, диск) и затем сохраняете их в кэш под новым ключом CRC32.




НЕМНОЖКО О BOOST(впервые с ним работаю)

BOOST - это обширный набор бесплатных рецензируемых библиотек для языка программирования C++, которые расширяют его функциональность и дополняют стандартную библиотеку

Примеры ключевых библиотек
Некоторые из наиболее известных и часто используемых библиотек включают:
Boost.Asio: для асинхронного ввода-вывода и сетевого программирования (основа для std::asio в C++17).
Boost.Thread: для управления потоками (многопоточное программирование), многие идеи вошли в std::thread.
Boost.Regex: для работы с регулярными выражениями (основа для std::regex).
Boost.Filesystem: для работы с файловой системой и путями (основа для std::filesystem в C++17).//КАК РАЗ НАШ СЛУЧАЙ В ЛАБЕ
Boost.Test: фреймворк для модульного тестирования (unit testing).


Ищем в BOOST модуль для работы с командной строкой!!!

Да, в библиотеке Boost есть модули для работы с командной строкой,
в основном через подсистему Boost.Program_options (для разбора аргументов и опций)
и иногда через Boost.Spirit (для парсинга) или Boost.Process (для запуска внешних команд),
хотя для простых задач часто достаточно стандартных средств C++ и POSIX/Windows API, а Boost предоставляет более мощные и переносимые решения.



РАБОТА С Boost.Program_options!!!!!!!!

Основные понятия:
1. po::value<T>() - создает хранилище для значения типа T

po::value<int>() - для целых чисел
po::value<std::string>() - для строк
po::value<std::vector<std::string>>() - для списка строк
2. Операторы для настройки:

->default_value(x) - значение по умолчанию
->multitoken() - параметр может принимать несколько значений
->required() - параметр обязательный
->implicit_value(x) - неявное значение (если указан флаг без значения)



ПЛАН:
1.Создать класс ScannerDirectory
2.Создать класс HASHH который будет хэшировать блоки
3.Класс DuplicateFinder который будет наследоваться от ScannerDirectory и HASHH
4.В main создадим объект класса DuplicateFinder с параметрами запустим



тест:
pasha@Mac sem3_lab7_c-- % ./build/bayan --include test_scanner --mask "*.txt"

pasha@Mac sem3_lab7_c-- % ./build/bayan --include test_scanner --mask "*" --level 1